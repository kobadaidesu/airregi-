"""
EDAノートブックを作成するスクリプト
exp01の特徴量エンジニアリングをクラスベースで再設計
"""

import json

# ノートブックのセル定義
cells = [
    # セル 1: タイトル
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "# AirREGI ヘルプデスク入電予測 - EDA & 特徴量エンジニアリング\n",
            "\n",
            "## 概要\n",
            "このノートブックでは、時系列データの探索的データ分析と特徴量エンジニアリングを行います。\n",
            "\n",
            "### 設計方針\n",
            "- **モジュール化**: 各特徴量グループをクラスで管理\n",
            "- **テスト容易性**: 各特徴量を独立してテスト可能\n",
            "- **データリーケージ防止**: 時系列データで未来の情報を使わない\n",
            "- **可読性**: コードの意図を明確に"
        ]
    },

    # セル 2: インポート
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# ライブラリのインポート\n",
            "import pandas as pd\n",
            "import numpy as np\n",
            "import matplotlib.pyplot as plt\n",
            "import seaborn as sns\n",
            "from datetime import timedelta\n",
            "from typing import List, Optional, Dict, Any\n",
            "import warnings\n",
            "warnings.filterwarnings('ignore')\n",
            "\n",
            "# 日本語フォント設定（文字化け対策）\n",
            "plt.rcParams['font.sans-serif'] = ['MS Gothic', 'Yu Gothic', 'DejaVu Sans']\n",
            "plt.rcParams['axes.unicode_minus'] = False\n",
            "\n",
            "# 表示設定\n",
            "pd.set_option('display.max_columns', 100)\n",
            "pd.set_option('display.max_rows', 100)\n",
            "\n",
            "print(\"Setup complete!\")"
        ]
    },

    # セル 3: セクションタイトル
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## 1. データ読み込み"
        ]
    },

    # セル 4: DataLoaderクラス
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "class DataLoader:\n",
            "    \"\"\"データ読み込みと前処理を行うクラス\"\"\"\n",
            "    \n",
            "    def __init__(self, input_dir: str = '../input'):\n",
            "        self.input_dir = input_dir\n",
            "        \n",
            "    def load_all(self) -> Dict[str, pd.DataFrame]:\n",
            "        \"\"\"全データを読み込み、日付型に変換\"\"\"\n",
            "        print(\"=\" * 80)\n",
            "        print(\"データ読み込み開始\")\n",
            "        print(\"=\" * 80)\n",
            "        \n",
            "        # データ読み込み\n",
            "        calender = pd.read_csv(f'{self.input_dir}/calender_data.csv')\n",
            "        cm_data = pd.read_csv(f'{self.input_dir}/cm_data.csv')\n",
            "        gt_service = pd.read_csv(f'{self.input_dir}/gt_service_name.csv')\n",
            "        acc_get = pd.read_csv(f'{self.input_dir}/regi_acc_get_data_transform.csv')\n",
            "        call_data = pd.read_csv(f'{self.input_dir}/regi_call_data_transform.csv')\n",
            "        \n",
            "        # 日付カラムをdatetime型に変換\n",
            "        calender['cdr_date'] = pd.to_datetime(calender['cdr_date'])\n",
            "        cm_data['cdr_date'] = pd.to_datetime(cm_data['cdr_date'])\n",
            "        acc_get['cdr_date'] = pd.to_datetime(acc_get['cdr_date'])\n",
            "        call_data['cdr_date'] = pd.to_datetime(call_data['cdr_date'])\n",
            "        gt_service['week'] = pd.to_datetime(gt_service['week'])\n",
            "        \n",
            "        # データサイズを表示\n",
            "        datasets = {\n",
            "            'calender': calender,\n",
            "            'cm_data': cm_data,\n",
            "            'gt_service': gt_service,\n",
            "            'acc_get': acc_get,\n",
            "            'call_data': call_data\n",
            "        }\n",
            "        \n",
            "        print(\"\\n読み込み完了:\")\n",
            "        for name, df in datasets.items():\n",
            "            print(f\"  {name:15s}: {df.shape}\")\n",
            "        \n",
            "        return datasets\n",
            "    \n",
            "    def merge_all(self, datasets: Dict[str, pd.DataFrame]) -> pd.DataFrame:\n",
            "        \"\"\"全データを統合\"\"\"\n",
            "        print(\"\\n\" + \"=\" * 80)\n",
            "        print(\"データ統合開始\")\n",
            "        print(\"=\" * 80)\n",
            "        \n",
            "        # メインデータ（入電数）を基準\n",
            "        df = datasets['call_data'].copy()\n",
            "        print(f\"\\nベースデータ: {df.shape}\")\n",
            "        \n",
            "        # カレンダー情報をマージ\n",
            "        df = df.merge(datasets['calender'], on='cdr_date', how='left')\n",
            "        print(f\"カレンダー統合後: {df.shape}\")\n",
            "        \n",
            "        # CM情報をマージ\n",
            "        df = df.merge(datasets['cm_data'], on='cdr_date', how='left')\n",
            "        print(f\"CM統合後: {df.shape}\")\n",
            "        \n",
            "        # アカウント取得数をマージ\n",
            "        df = df.merge(datasets['acc_get'], on='cdr_date', how='left')\n",
            "        print(f\"アカウント取得数統合後: {df.shape}\")\n",
            "        \n",
            "        # Google Trendsを週次→日次に展開\n",
            "        gt_daily = self._expand_weekly_to_daily(datasets['gt_service'])\n",
            "        df = df.merge(gt_daily, on='cdr_date', how='left')\n",
            "        print(f\"Google Trends統合後: {df.shape}\")\n",
            "        \n",
            "        # 日付でソート（時系列処理のため必須）\n",
            "        df = df.sort_values('cdr_date').reset_index(drop=True)\n",
            "        print(\"\\n日付でソート完了（時系列処理のため）\")\n",
            "        \n",
            "        # 欠損値確認\n",
            "        print(\"\\n欠損値の数（上位10）:\")\n",
            "        missing = df.isnull().sum().sort_values(ascending=False).head(10)\n",
            "        for col, count in missing.items():\n",
            "            if count > 0:\n",
            "                print(f\"  {col:30s}: {count:4d} ({count/len(df)*100:.1f}%)\")\n",
            "        \n",
            "        return df\n",
            "    \n",
            "    @staticmethod\n",
            "    def _expand_weekly_to_daily(gt_service: pd.DataFrame) -> pd.DataFrame:\n",
            "        \"\"\"週次データを日次に展開\"\"\"\n",
            "        print(\"\\nGoogle Trendsを週次→日次に展開中...\")\n",
            "        daily_records = []\n",
            "        \n",
            "        for _, row in gt_service.iterrows():\n",
            "            week_start = row['week']\n",
            "            for i in range(7):\n",
            "                date = week_start + timedelta(days=i)\n",
            "                daily_records.append({\n",
            "                    'cdr_date': date,\n",
            "                    'search_cnt': row['search_cnt']\n",
            "                })\n",
            "        \n",
            "        return pd.DataFrame(daily_records)\n",
            "\n",
            "\n",
            "# データ読み込み実行\n",
            "loader = DataLoader()\n",
            "datasets = loader.load_all()\n",
            "df_raw = loader.merge_all(datasets)\n",
            "\n",
            "print(\"\\n\" + \"=\" * 80)\n",
            "print(f\"統合データ: {df_raw.shape}\")\n",
            "print(f\"期間: {df_raw['cdr_date'].min()} ~ {df_raw['cdr_date'].max()}\")\n",
            "print(\"=\" * 80)"
        ]
    },

    # セル 5: 特徴量エンジニアリングのセクション
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## 2. 特徴量エンジニアリング\n",
            "\n",
            "### 設計パターン\n",
            "各特徴量グループを独立したクラスとして実装し、テストと保守を容易にします。"
        ]
    },

    # セル 6: 特徴量エンジニアリングクラス群
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "from abc import ABC, abstractmethod\n",
            "\n",
            "class BaseFeatureEngineer(ABC):\n",
            "    \"\"\"特徴量エンジニアリングの基底クラス\"\"\"\n",
            "    \n",
            "    def __init__(self, name: str):\n",
            "        self.name = name\n",
            "        self.created_features: List[str] = []\n",
            "    \n",
            "    @abstractmethod\n",
            "    def create_features(self, df: pd.DataFrame) -> pd.DataFrame:\n",
            "        \"\"\"特徴量を作成（サブクラスで実装）\"\"\"\n",
            "        pass\n",
            "    \n",
            "    def get_feature_names(self) -> List[str]:\n",
            "        \"\"\"作成された特徴量名のリストを取得\"\"\"\n",
            "        return self.created_features\n",
            "    \n",
            "    def describe(self, df: pd.DataFrame) -> pd.DataFrame:\n",
            "        \"\"\"特徴量の統計情報を取得\"\"\"\n",
            "        if not self.created_features:\n",
            "            print(f\"{self.name}: 特徴量が未作成です\")\n",
            "            return pd.DataFrame()\n",
            "        return df[self.created_features].describe()\n",
            "\n",
            "\n",
            "class TimeBasedFeatures(BaseFeatureEngineer):\n",
            "    \"\"\"日付から派生する基本的な時系列特徴量\n",
            "    \n",
            "    これらは未来の情報を使わないため、データリーケージの心配がありません。\n",
            "    \"\"\"\n",
            "    \n",
            "    def __init__(self):\n",
            "        super().__init__(\"時系列基本特徴量\")\n",
            "    \n",
            "    def create_features(self, df: pd.DataFrame) -> pd.DataFrame:\n",
            "        df = df.copy()\n",
            "        \n",
            "        # 年月日の特徴量\n",
            "        df['year'] = df['cdr_date'].dt.year\n",
            "        df['month'] = df['cdr_date'].dt.month\n",
            "        df['day_of_month'] = df['cdr_date'].dt.day\n",
            "        df['quarter'] = df['cdr_date'].dt.quarter\n",
            "        df['day_of_year'] = df['cdr_date'].dt.dayofyear\n",
            "        df['week_of_year'] = df['cdr_date'].dt.isocalendar().week\n",
            "        \n",
            "        # 経過日数\n",
            "        df['days_from_start'] = (df['cdr_date'] - df['cdr_date'].min()).dt.days\n",
            "        \n",
            "        # 月初・月末フラグ\n",
            "        df['is_month_start'] = (df['day_of_month'] <= 5).astype(int)\n",
            "        df['is_month_end'] = (df['day_of_month'] >= 25).astype(int)\n",
            "        \n",
            "        # 週初・週末（既存のdowを利用）\n",
            "        if 'dow' in df.columns:\n",
            "            df['is_week_start'] = (df['dow'] == 1).astype(int)  # 月曜\n",
            "            df['is_week_end'] = (df['dow'] == 5).astype(int)    # 金曜\n",
            "        \n",
            "        self.created_features = [\n",
            "            'year', 'month', 'day_of_month', 'quarter', 'day_of_year',\n",
            "            'week_of_year', 'days_from_start', 'is_month_start', 'is_month_end',\n",
            "            'is_week_start', 'is_week_end'\n",
            "        ]\n",
            "        \n",
            "        print(f\"{self.name}: {len(self.created_features)}個の特徴量を作成\")\n",
            "        return df\n",
            "\n",
            "\n",
            "class LagFeatures(BaseFeatureEngineer):\n",
            "    \"\"\"ラグ特徴量（過去のデータ）\n",
            "    \n",
            "    重要:\n",
            "    - shift()を使って未来の情報が混入しないようにする\n",
            "    - データは日付順にソート済みであることが前提\n",
            "    \"\"\"\n",
            "    \n",
            "    def __init__(self, target_col: str = 'call_num', lags: List[int] = [1, 2, 3, 5, 7, 14, 30]):\n",
            "        super().__init__(\"ラグ特徴量\")\n",
            "        self.target_col = target_col\n",
            "        self.lags = lags\n",
            "    \n",
            "    def create_features(self, df: pd.DataFrame) -> pd.DataFrame:\n",
            "        df = df.copy()\n",
            "        \n",
            "        if self.target_col not in df.columns:\n",
            "            print(f\"警告: {self.target_col}が見つかりません\")\n",
            "            return df\n",
            "        \n",
            "        for lag in self.lags:\n",
            "            col_name = f'lag_{lag}'\n",
            "            df[col_name] = df[self.target_col].shift(lag)\n",
            "            self.created_features.append(col_name)\n",
            "        \n",
            "        print(f\"{self.name}: {len(self.created_features)}個の特徴量を作成\")\n",
            "        print(f\"  対象変数: {self.target_col}\")\n",
            "        print(f\"  ラグ: {self.lags}\")\n",
            "        print(f\"  注意: 最初の{max(self.lags)}日間はNaNになります\")\n",
            "        \n",
            "        return df\n",
            "\n",
            "\n",
            "class RollingFeatures(BaseFeatureEngineer):\n",
            "    \"\"\"移動統計量特徴量（移動平均、移動標準偏差など）\n",
            "    \n",
            "    重要:\n",
            "    - rolling()の前にshift(1)を適用してデータリーケージを防止\n",
            "    - 当日のデータが含まれないようにする\n",
            "    \"\"\"\n",
            "    \n",
            "    def __init__(self, target_col: str = 'call_num', windows: List[int] = [3, 7, 14, 30]):\n",
            "        super().__init__(\"移動統計量特徴量\")\n",
            "        self.target_col = target_col\n",
            "        self.windows = windows\n",
            "    \n",
            "    def create_features(self, df: pd.DataFrame) -> pd.DataFrame:\n",
            "        df = df.copy()\n",
            "        \n",
            "        if self.target_col not in df.columns:\n",
            "            print(f\"警告: {self.target_col}が見つかりません\")\n",
            "            return df\n",
            "        \n",
            "        for window in self.windows:\n",
            "            # 移動平均（当日を含まない）\n",
            "            ma_col = f'ma_{window}'\n",
            "            df[ma_col] = df[self.target_col].shift(1).rolling(\n",
            "                window=window, min_periods=1\n",
            "            ).mean()\n",
            "            self.created_features.append(ma_col)\n",
            "            \n",
            "            # 移動標準偏差（変動性を捉える）\n",
            "            std_col = f'ma_std_{window}'\n",
            "            df[std_col] = df[self.target_col].shift(1).rolling(\n",
            "                window=window, min_periods=1\n",
            "            ).std()\n",
            "            self.created_features.append(std_col)\n",
            "            \n",
            "            # 移動最大値\n",
            "            max_col = f'ma_max_{window}'\n",
            "            df[max_col] = df[self.target_col].shift(1).rolling(\n",
            "                window=window, min_periods=1\n",
            "            ).max()\n",
            "            self.created_features.append(max_col)\n",
            "            \n",
            "            # 移動最小値\n",
            "            min_col = f'ma_min_{window}'\n",
            "            df[min_col] = df[self.target_col].shift(1).rolling(\n",
            "                window=window, min_periods=1\n",
            "            ).min()\n",
            "            self.created_features.append(min_col)\n",
            "        \n",
            "        print(f\"{self.name}: {len(self.created_features)}個の特徴量を作成\")\n",
            "        print(f\"  対象変数: {self.target_col}\")\n",
            "        print(f\"  ウィンドウ: {self.windows}\")\n",
            "        print(f\"  統計量: 平均, 標準偏差, 最大値, 最小値\")\n",
            "        \n",
            "        return df\n",
            "\n",
            "\n",
            "class DomainFeatures(BaseFeatureEngineer):\n",
            "    \"\"\"ドメイン知識に基づく特徴量\n",
            "    \n",
            "    - CM効果の累積\n",
            "    - Google Trendsの平滑化\n",
            "    - アカウント取得数の傾向\n",
            "    - 曜日ごとの過去平均\n",
            "    \"\"\"\n",
            "    \n",
            "    def __init__(self):\n",
            "        super().__init__(\"ドメイン特徴量\")\n",
            "    \n",
            "    def create_features(self, df: pd.DataFrame) -> pd.DataFrame:\n",
            "        df = df.copy()\n",
            "        \n",
            "        # CM効果の累積（過去7日間のCM実施回数）\n",
            "        if 'cm_flg' in df.columns:\n",
            "            df['cm_7d_sum'] = df['cm_flg'].shift(1).rolling(window=7, min_periods=1).sum()\n",
            "            df['cm_14d_sum'] = df['cm_flg'].shift(1).rolling(window=14, min_periods=1).sum()\n",
            "            self.created_features.extend(['cm_7d_sum', 'cm_14d_sum'])\n",
            "        \n",
            "        # Google Trendsの移動平均（ノイズ除去）\n",
            "        if 'search_cnt' in df.columns:\n",
            "            df['gt_ma_7'] = df['search_cnt'].shift(1).rolling(window=7, min_periods=1).mean()\n",
            "            df['gt_ma_14'] = df['search_cnt'].shift(1).rolling(window=14, min_periods=1).mean()\n",
            "            self.created_features.extend(['gt_ma_7', 'gt_ma_14'])\n",
            "        \n",
            "        # アカウント取得数の移動平均\n",
            "        if 'acc_get_cnt' in df.columns:\n",
            "            df['acc_ma_7'] = df['acc_get_cnt'].shift(1).rolling(window=7, min_periods=1).mean()\n",
            "            df['acc_ma_14'] = df['acc_get_cnt'].shift(1).rolling(window=14, min_periods=1).mean()\n",
            "            self.created_features.extend(['acc_ma_7', 'acc_ma_14'])\n",
            "        \n",
            "        # 曜日ごとの過去平均（同じ曜日のパターンを捉える）\n",
            "        if 'dow' in df.columns and 'call_num' in df.columns:\n",
            "            df['dow_avg'] = np.nan\n",
            "            for dow in df['dow'].unique():\n",
            "                mask = df['dow'] == dow\n",
            "                df.loc[mask, 'dow_avg'] = df.loc[mask, 'call_num'].shift(1).expanding().mean()\n",
            "            self.created_features.append('dow_avg')\n",
            "        \n",
            "        print(f\"{self.name}: {len(self.created_features)}個の特徴量を作成\")\n",
            "        return df\n",
            "\n",
            "\n",
            "print(\"特徴量エンジニアリングクラス定義完了\")"
        ]
    },
]

# ノートブック構造
notebook = {
    "cells": cells,
    "metadata": {
        "kernelspec": {
            "display_name": "Python 3",
            "language": "python",
            "name": "python3"
        },
        "language_info": {
            "name": "python",
            "version": "3.8.0"
        }
    },
    "nbformat": 4,
    "nbformat_minor": 5
}

# 保存
output_path = r'c:\Users\PC_User\Documents\gci_airregi\kaggle-template\notebook\eda.ipynb'
with open(output_path, 'w', encoding='utf-8') as f:
    json.dump(notebook, f, indent=1, ensure_ascii=False)

print(f"EDAノートブックを作成しました: {output_path}")
print(f"セル数: {len(cells)}")
